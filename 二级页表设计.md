### 二级页表设计

一个页表映射的内存大小是4KB。一个页目录项有1024个表项（0-1023），其中一个表项可以映射到的内存大小是：4byte *1024 *1024 => 4MB。

其中页目录项我打算分3GB给用户进程，1GB分给内核进程。所以用户进程的表项=> 3GB/4MB => 768。也就是说页目录项中的0-767项映射为用户进程，而从768项开始一直到1023项都映射的是内核进程。

在实际物理内存中：

- **内核**位于物理内存中的低1MB中，即`0-0xfffff`
- 紧接着从`0x100000-0x100fff`这4KB存放的是**页目录项表**
- 再往下的`0x101000开始`即是**页表**的存放处



创建PDE（表目录项）和PTE（页表条目）的本质其实就是**映射**。
-> 创建PDE：完成`表目录项-页表地址`的映射
-> 创建PTE：完成`页表条目-物理页`的映射



目录项表对于物理页的映射情况如下：

```
—————————————————— 0x100000(低)
|___mbr、loader___| => 为适应分页前，也映射内核的1MB空间
|		 		  |
|		 		  |
|		3G	      |	
|				  |
|—————————————————|0x100c00
|    1G映射内核    | => 映射物理内存上1MB的内核空间
—————————————————— 0x101000(高)
```
页目录项0和0xc00这两个都映射同一个页表->【第一个页表】，这个页表映射4MB物理内存，前1MB中是内核。



对于用户进程的实现，打算让每个用户进程都有独立的4GB虚拟空间，其中这4GB的低3GB为用户进程空间，高1GB分配给内核空间。所以由此看出内核将会被所有用户进程共享，它们的高1GB都指向内核所在的物理内存，也就是说**所有用户进程的第768-第1022个页目录项（共254项）都是一样的**（1023个页目录项指向它们的页目录表自身）



页目录项、页表条目、物理页的关系be like：

![](https://github.com/yanyanran/pictures/blob/main/page.jpg?raw=true)



每个进程拥有4GB的虚拟地址分布如下：
0x00000000-0x3fffffff -> 第一个GB
0x40000000-0x7fffffff -> 第二个GB
0x80000000-0xbfffffff -> 第三个GB
**0xc0000000-0xffffffff** -> 第四个GB【**内核地址**】



##### 虚拟地址-> 物理地址的映射过程：

1、从cr3寄存器获取页目录表物理地址
2、用虚拟地址的高10位 * 4-> 作为在页目录表中的偏移量去寻址**目录项PDE**
3、从PDE中读出**页表**物理地址 
4、用虚拟地址的中间10位 * 4-> 作为在页表中的偏移量去寻址**页表项PTE**
5、从PTE中读出**页**物理地址
6、用虚拟地址的低12位作为该物理页的偏移量