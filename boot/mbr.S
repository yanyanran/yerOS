;主引导程序

SECTION MBR vstart=0x7c00 ;指定引导程序的起始(段)地址
    mov ax,cs       ;ax:通用寄存器
    ;段寄存器
    mov ds,ax
    mov es,ax
    mov ss,ax
    mov fs,ax
    mov sp,0x7c00   ;初始化栈指针 

; -----------------------------------------------------------
;INT 0x10
;功能号:0x06-> 上卷窗口(清屏)
;------------------------------------------------------

    mov ax, 0x600   ; AH 功能号= 0x06, AL = 上卷行数(为0表示全部)
    mov bx, 0x700   ; BH = 上卷行属性
    mov cx, 0       ; (CL,CH) = 窗口左上角的(X,Y)位置-> 左上角: (0, 0)
    mov dx, 0x184f  ; (DL,DH) = 窗口右下角的(X,Y)位置-> 右下角: (80,25),
                    ; VGA 文本模式中,一行只能容纳 80 个字符,共 25 行｡
                    ; 下标从 0 开始,所以 0x18=24,0x4f=79
    int 0x10


;下面这三行代码获取光标位置
;.get_cursor 获取当前光标位置,在光标位置处打印字符｡
    mov ah, 3   ; 3号功能=获取光标位置,需要存入 ah 寄存器
    mov bh, 0   ; bh 寄存器存储: 待获取光标的页号
    int 0x10    ; 输出: ch=光标开始行,cl=光标结束行
                ; dh=光标所在行号,dl=光标所在列号

;打印字符串
;还是用 10h 中断,不过这次调用 13 号子功能打印字符串
    ;mov ax, 
    mov bp, message  ; es:bp 为串首地址,es 此时同 cs 一致,
    
    ; 光标位置要用到 dx 寄存器中内容,cx 中的光标位置可忽略
    mov cx, 5           ; cx 为串长度,不包括结束符 0 的字符个数
    mov ax, 0x1301      ;子功能号 13 显示字符及属性,要存入 ah 寄存器,
                        ; al 设置写字符方式 ah=01: 显示字符串,光标跟随移动
    mov bx, 0x2         ; bh 存储要显示的页号,此处是第 0 页,
                        ; bl 中是字符属性,属性黑底绿字(bl = 02h)
    int 0x10


    jmp $       ; 使程序悬停在此
    
    message db "1 MBR" ;定义打印的字符串
    times 510-($-$$) db 0 ;用0填充本扇区除了最后两个魔数的剩余空间
    db 0x55,0xaa